# Import types
import time
from beanie import Document
from typing import Optional, List, Dict
from pydantic import BaseModel, model_validator


# Define afk config
# class afkConfig(BaseModel):

#     style: int = 0

#     enabled: True


class automoderatorSettings(BaseModel):
    """
    - enabled - `bool` - Whether automod is enabled. Defaults to True
    - moderateBots - `bool` - Whether to moderate bot messages. Defaults to False
    - moderateOwner - `bool` - Whether to moderate the server owner. Defaults to False.
    """

    enabled: bool = True
    moderateBots: bool = False
    moderateOwner: bool = False


class automoderatorModules(BaseModel):
    """
    - slurs - `bool` - Whether anti-slurs module is enabled. Defaults to False
    - profanity - `bool` - Whether anti-profanity module is enabled. Defaults to False
    - invites - `bool` - Whether anti-invites module is enabled. Defaults to False
    """

    slurs: bool = False
    profanity: bool = False
    invites: bool = False


class loggingSettings(BaseModel):
    """
    - enabled - `bool` - Whether logging is enabled. Defaults to True
    - logBotMessageChanges - `bool` - Whether to log message changes (deletions/edits) from bots. Defaults to False
    """

    enabled: bool = True
    logBotMessageChanges: bool = False


# Define logging channels
class loggingChannels(BaseModel):
    """
    - logSettings - `loggingSettings` - Server logging settings
    - setChannels - `dict` - Every logging channel. Prevents a logging channel from being set multiple times. (key (channel id): eventType)

    - allEvents - `list[str]` - All events

    - allChannelEvents - `list[str]` - All channel related events (documentUpdate, announcementUpdate, forumUpdate, calendarUpdate, channelStateUpdate)
    - allMemberEvents - `list[str]` - All member related events (membershipChange, memberUpdate)

    - membershipChange - `list[str]` - Membership related events. (Joins/Leaves/Kicks/Bans)
    - memberUpdate - `list[str]` - Member update related events (nickname, roles)

    - automod - `list[str]` - Moderation actions generated by the AutoMod.
    - messageChange -` list[str]` - message updated/deleted
    - moderatorAction - `list[str]` - moderator made an action
    - botSettingChanges - `list[str]` - Bot setting was changed

    - channelStateUpdate - `list[str]` - Channel state changes.
    - forumUpdate - `list[str]` - Forum post was updated
    - documentUpdate - `list[str]` - Document was updated
    - announcementUpdate - `list[str]` - Announcement was updated
    - listUpdate - `list[str]` - List was updated
    - categoryUpdate - `list[str]` - Category was updated
    """

    logSettings: loggingSettings = loggingSettings()

    setChannels: dict = {}

    allEvents: List[str] = list()

    allChannelEvents: List[str] = list()

    allMemberEvents: List[str] = list()

    membershipChange: List[str] = list()

    memberUpdate: List[str] = list()

    automod: List[str] = list()

    botSettingChanges: List[str] = list()

    messageChange: List[str] = list()

    moderatorAction: List[str] = list()

    channelStateUpdate: List[str] = list()

    forumUpdate: List[str] = list()

    documentUpdate: List[str] = list()

    announcementUpdate: List[str] = list()

    calendarUpdate: List[str] = list()

    listUpdate: List[str] = list()

    categoryUpdate: List[str] = list()


class punishmentData(BaseModel):
    """
    - action - `str` - The actual action taken
    - duration - `int` - In seconds, the duration of action if action is tempban or tempmute
    """

    action: str = None
    duration: int = 0

    @model_validator(mode="after")
    def created_validator(self):
        assert self.action in [
            "kick",
            "ban",
            "mute",
            "tempban",
            "tempmute",
            "warn",
            None,
        ]
        if self.action == None:
            self.action == "Unspecified"
        return self


class automodRule(BaseModel):
    """
    - author - `str` - ID of the author of the rule
    - rule - `str` - The actual regex or string rule
    - regex - `bool` - Whether it's regex or not (defaults to False)
    - description - `Optional[str]` - The automod rule description (defaults to None)
    - punishment - `punishmentData` - Punishment data, action and duration
    - enabled - `bool` - Whether the rule is enabled or not (defaults to True)
    - custom_message - `Optional[str]` - Custom message given to user
    - custom_reason - `Optional[str]` - Custom reason that's logged as the warning or note or whatever
    - created - `int` - Created at timestamp in epoch seconds - Automatically generated when rule is made
    - extra_data - `dict` - Automod rule extra data
    """

    author: str
    rule: str
    regex: bool = False
    punishment: punishmentData = punishmentData()
    description: Optional[str] = None
    custom_message: Optional[str] = None
    custom_reason: Optional[str] = None
    enabled: bool = True
    created: int = None
    extra_data: dict = {}

    @model_validator(mode="after")
    def created_validator(self):
        if self.created is None:
            self.created = round(time.time())
        assert self.author and self.rule and self.punishment != {}
        return self


class serverRoles(BaseModel):
    """
    - mute - `Optional[int]` - The server's mute role.
    """

    mute: Optional[int] = None


class serverSettings(BaseModel):
    """
    - roles - `serverRoles` - The sever's roles settings.
    """

    roles: serverRoles = serverRoles()


class serverMute(BaseModel):
    """
    - user - `str` - The muted user's id.
    - muteRole - `int` - The muted role given to the user. By default, the bot should attempt to remove this role first on unmute, but also try to remove the new mute role if exists. This should be overwritten if the user leaves and rejoins, to apply the new mute role.
    - endsAt - `Optional[int]` - When the punishment ends, if tempmute. TODO: check this and remove in a task in moderation cog
    """

    user: str
    muteRole: int
    endsAt: Optional[int] = None


class serverBan(BaseModel):
    """
    - user - `str` - The muted user's id.
    - endsAt - `Optional[int]` - When the punishment ends, if tempban. TODO: check this and remove in a task in moderation cog
    - reason - `Optional[str]` - The reason for the ban.
    """

    user: str
    endsAt: Optional[int] = None
    reason: Optional[str] = None


class serverData(BaseModel):
    """
    - automodRules - `List[automodRule]` - The server's automod rules
    - automodSettings - `automoderatorSettings` - Automod settings
    - automodModules - `automoderatorModules` - Automod default modules
    - settings - `serverSettings` - The server's settings.
    - mutes - `List[serverMute]` - The server's current saved mutes.
    - bans - `List[serverBan]` - The server's current saved bans.
    """

    automodRules: List[automodRule] = list()

    automodSettings: automoderatorSettings = automoderatorSettings()

    automodModules: automoderatorModules = automoderatorModules()

    settings: serverSettings = serverSettings()

    mutes: List[serverMute] = list()

    bans: List[serverBan] = list()


class HistoryCase(BaseModel):
    """
    - caseId - `str` - The case id.
    - actions - `List[str]` - The actions taken. Must be a list of strings.
    - reason - `Optional[str]` - The reason, if provided. Else, None.
    - moderator - `str` -  The moderator's id.
    - duration - `Optional[List[int]]` - The durations of the actions. Format: [tempmute, tempban]
    - automod - `bool` - Whether the case was because of automod.
    """

    caseId: str
    actions: List[str]
    reason: Optional[str] = None
    moderator: str
    duration: Optional[List[int]] = None
    automod: bool = False


class serverMember(BaseModel):
    """
    - member - `str` - The member's ID
    - history - `Dict[str, HistoryCase]` - The user's history of cases.

    # TODO: tempmute and tempban durations here
    """

    member: str
    history: Dict[str, HistoryCase] = dict()


class RSSFeed(BaseModel):
    """
    - channelId - `str` - The channel id
    - feedURL - `str` - The feed's URL
    - last_checked - `tuple` - When last checked. See: https://feedparser.readthedocs.io/en/latest/date-parsing.html
    """

    channelId: str
    feedURL: str
    last_checked: Optional[tuple] = None


# Define the server document
class Server(Document):
    """
    - serverId - `str` - The server's Id.
    - prefix - `Optional[str]` - The server's prefix.
    - logging - `LoggingChannels` - Logging channels for events.
    - rssFeeds - `List[RSSFeed]` - Server RSS feed channels.
    - members - `Dict[str, ServerMember]` - Members data and punishment log. (Defaults to {})
    - cases - `Dict[str, str]` - Maps a caseID to a user
    - eventIds - `Dict[str, str]` - Maps a eventID to a eventType to show it was used
    - data - `serverData` - Server data and configs.
    """

    serverId: str

    prefix: Optional[str] = None

    logging: loggingChannels = loggingChannels()

    rssFeeds: List[RSSFeed] = list()

    members: Dict[str, serverMember] = dict()

    cases: Dict[str, str] = dict()

    eventIds: Dict[str, str] = dict()

    data: serverData = serverData()
